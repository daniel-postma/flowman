<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>JLPT Hangman</title>
    <style>
      :root {
        --bg: #0b0f17;
        --text: #e7eefc;
        --muted: #a9b7d6;
        --accent: #7aa2ff;
        --danger: #ff6b6b;
        --ok: #4fe3a5;
        --radius: 16px;
        --shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 16px;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
        background: radial-gradient(
            1200px 600px at 20% 10%,
            rgba(122, 162, 255, 0.18),
            transparent 60%
          ),
          radial-gradient(
            1000px 500px at 90% 20%,
            rgba(79, 227, 165, 0.14),
            transparent 55%
          ),
          var(--bg);
        color: var(--text);
        min-height: 100vh;
        display: flex;
        justify-content: center;
      }
      .app {
        width: min(1100px, 100%);
        display: grid;
        grid-template-columns: 1.1fr 0.9fr;
        gap: 16px;
      }
      @media (max-width: 900px) {
        .app {
          grid-template-columns: 1fr;
        }
      }

      .card {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.03),
          rgba(255, 255, 255, 0.01)
        );
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: var(--radius);
        box-shadow: var(--shadow);
        overflow: hidden;
      }
      .cardHeader {
        padding: 14px 16px;
        background: rgba(255, 255, 255, 0.03);
        border-bottom: 1px solid rgba(255, 255, 255, 0.07);
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
      }
      .title {
        font-weight: 900;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .content {
        padding: 16px;
      }
      .row {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      .btn {
        appearance: none;
        cursor: pointer;
        user-select: none;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(0, 0, 0, 0.18);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        font-weight: 800;
        transition: transform 0.05s ease, border-color 0.15s ease,
          background 0.15s ease;
      }
      .btn:hover {
        border-color: rgba(122, 162, 255, 0.6);
        background: rgba(122, 162, 255, 0.1);
      }
      .btn:active {
        transform: translateY(1px);
      }
      .btn.primary {
        border-color: rgba(122, 162, 255, 0.7);
        background: rgba(122, 162, 255, 0.18);
      }
      .btn.ok {
        border-color: rgba(79, 227, 165, 0.6);
        background: rgba(79, 227, 165, 0.1);
      }
      .btn.danger {
        border-color: rgba(255, 107, 107, 0.7);
        background: rgba(255, 107, 107, 0.1);
      }
      .btn:disabled {
        opacity: 0.45;
        cursor: not-allowed;
      }

      select,
      input[type="text"] {
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.15);
        background: rgba(0, 0, 0, 0.2);
        color: var(--text);
        outline: none;
        font-weight: 700;
      }
      .labelTiny {
        color: var(--muted);
        font-size: 12px;
        font-weight: 900;
      }

      .bigKanji {
        font-size: 56px;
        font-weight: 950;
        line-height: 1.05;
        margin: 6px 0 6px;
        word-break: break-word;
      }
      .meaning {
        margin: 0 0 10px;
        color: var(--muted);
        font-size: 18px;
      }
      .meaning.hard {
        color: var(--text);
        font-size: 30px;
        font-weight: 950;
        line-height: 1.2;
        margin-top: 8px;
      }
      .subline {
        color: var(--muted);
        font-size: 13px;
        margin: 0 0 14px;
      }

      .blanks {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        align-items: flex-end;
        margin: 12px 0 16px;
        min-height: 56px;
      }
      .slot {
        width: 34px;
        height: 46px;
        display: flex;
        align-items: center;
        justify-content: center;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.18);
        border: 1px solid rgba(255, 255, 255, 0.1);
        font-size: 22px;
        font-weight: 950;
        text-transform: lowercase;
      }
      .slot.revealed {
        border-color: rgba(79, 227, 165, 0.55);
        background: rgba(79, 227, 165, 0.08);
      }

      .guessBar {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }

      /* Keyboard (QWERTY / Kana) */
      .kbdHint {
        color: var(--muted);
        font-size: 12px;
        margin-top: 10px;
      }
      .kbdWrap {
        margin-top: 10px;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .kbdRow {
        display: flex;
        gap: 8px;
        justify-content: center;
        flex-wrap: nowrap;
      }
      .key {
        padding: 10px 0;
        border-radius: 12px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.16);
        color: var(--text);
        font-weight: 950;
        cursor: pointer;
        text-transform: lowercase;
        user-select: none;
        min-width: 34px;
        flex: 1 1 0px;
      }
      .key:hover {
        border-color: rgba(122, 162, 255, 0.55);
        background: rgba(122, 162, 255, 0.1);
      }
      .key.used {
        opacity: 0.35;
        cursor: not-allowed;
      }
      .key.good {
        border-color: rgba(79, 227, 165, 0.55);
        background: rgba(79, 227, 165, 0.08);
      }
      .key.bad {
        border-color: rgba(255, 107, 107, 0.6);
        background: rgba(255, 107, 107, 0.1);
      }
      .key.wide {
        flex: 2 1 0px;
      }
      .key.kana {
        text-transform: none;
        font-weight: 900;
      }
      .key.kana.used,
      .key.kana.good,
      .key.kana.bad {
        /* kana keys shouldn't be "used" */
      }

      /* MCQ (Hard mode) */
      .mcqArea {
        margin-top: 14px;
        display: none;
      }
      .mcqGrid {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: 10px;
        margin-top: 10px;
      }
      @media (max-width: 700px) {
        .mcqGrid {
          grid-template-columns: repeat(2, minmax(0, 1fr));
        }
      }
      .mcqBtn {
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.14);
        background: rgba(0, 0, 0, 0.18);
        color: var(--text);
        padding: 12px 10px;
        font-weight: 950;
        cursor: pointer;
        user-select: none;
        text-align: center;
      }
      .mcqBtn:hover {
        border-color: rgba(122, 162, 255, 0.55);
        background: rgba(122, 162, 255, 0.1);
      }
      .mcqBtn.bad {
        border-color: rgba(255, 107, 107, 0.7);
        background: rgba(255, 107, 107, 0.1);
        opacity: 0.55;
        cursor: not-allowed;
      }
      .mcqBtn.good {
        border-color: rgba(79, 227, 165, 0.6);
        background: rgba(79, 227, 165, 0.1);
      }

      .rightPanel {
        display: flex;
        flex-direction: column;
        gap: 16px;
      }
      .artWrap {
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.18);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 16px;
        padding: 12px;
        min-height: 280px;
        position: relative;
        overflow: hidden;
      }
      canvas {
        width: 240px;
        height: 240px;
        image-rendering: pixelated;
        border-radius: 12px;
        background: rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.08);
      }
      .artFallback {
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        text-align: center;
        padding: 18px;
        color: var(--muted);
        font-weight: 900;
        line-height: 1.4;
      }

      .statGrid {
        display: grid;
        grid-template-columns: repeat(2, minmax(0, 1fr));
        gap: 10px;
        margin-top: 12px;
      }
      .stat {
        background: rgba(0, 0, 0, 0.14);
        border: 1px solid rgba(255, 255, 255, 0.08);
        border-radius: 14px;
        padding: 10px 12px;
      }
      .stat .label {
        font-size: 12px;
        color: var(--muted);
        margin-bottom: 2px;
      }
      .stat .value {
        font-size: 20px;
        font-weight: 950;
      }

      .toast {
        margin-top: 12px;
        padding: 10px 12px;
        border-radius: 14px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: rgba(0, 0, 0, 0.18);
        color: var(--muted);
        min-height: 44px;
        display: flex;
        align-items: center;
        gap: 10px;
      }
      .dot {
        width: 10px;
        height: 10px;
        border-radius: 999px;
        background: rgba(255, 255, 255, 0.25);
      }
      .dot.ok {
        background: rgba(79, 227, 165, 0.7);
      }
      .dot.bad {
        background: rgba(255, 107, 107, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="app">
      <!-- LEFT: GAME -->
      <section class="card">
        <div class="cardHeader">
          <div class="title">JLPT Hangman</div>

          <div class="row">
            <span class="labelTiny">Mode:</span>
            <select id="modeSelect" aria-label="Mode">
              <option value="easy">Easy</option>
              <option value="normal">Normal</option>
              <option value="hard">Hard</option>
            </select>

            <span class="labelTiny" style="margin-left: 8px">Level:</span>
            <select id="levelSelect" aria-label="Level"></select>
            <button class="btn" id="btnPrevLevel">◀</button>
            <button class="btn" id="btnNextLevel">▶</button>
          </div>

          <!-- hidden debug only -->
          <span id="statusPill" style="display: none">Loading…</span>
        </div>

        <div class="content">
          <div class="row" style="margin-bottom: 12px">
            <button class="btn primary" id="btnLoadLevel" disabled>
              Load Level
            </button>
            <button class="btn ok" id="btnStart" disabled>Start</button>
            <button class="btn danger" id="btnResetRun" disabled>
              Reset Run
            </button>
          </div>

          <div id="gameArea">
            <div class="bigKanji" id="kanjiText">—</div>
            <p class="meaning" id="meaningText">—</p>
            <p class="subline" id="furiganaLine" style="display: none">
              Furigana: —
            </p>

            <div class="blanks" id="blanks"></div>

            <div class="guessBar" id="guessBar">
              <input
                id="fullGuess"
                type="text"
                placeholder="Type romaji and press Enter…"
                autocomplete="off"
                spellcheck="false"
              />
              <input
                id="kanaGuess"
                type="text"
                placeholder="Click hiragana below…"
                autocomplete="off"
                spellcheck="false"
                readonly
                style="display: none"
              />
              <button class="btn ok" id="btnSubmit">Submit</button>
              <button class="btn" id="btnHint">Hint</button>
              <button class="btn danger" id="btnSkip">Skip</button>
            </div>

            <div class="kbdHint" id="kbdHint">Click letters (QWERTY).</div>
            <div class="kbdWrap" id="keyboard"></div>

            <div class="mcqArea" id="mcqArea">
              <div class="kbdHint" id="mcqHint">
                Pick the correct reading (same level).
              </div>
              <div class="mcqGrid" id="mcqGrid"></div>
            </div>

            <div class="toast" id="toast">
              <span class="dot"></span>
              <span id="toastText">Loading jlpt_vocab.csv…</span>
            </div>
          </div>
        </div>
      </section>

      <!-- RIGHT: ANIMATION + STATS -->
      <aside class="rightPanel">
        <section class="card">
          <div class="cardHeader">
            <div class="title">Animation + Music</div>
            <div class="row">
              <button class="btn" id="btnMusic">Play Music</button>
            </div>
          </div>

          <div class="content">
            <div class="artWrap">
              <canvas
                id="spriteCanvas"
                width="240"
                height="240"
                aria-label="sleep_kev animation"
              ></canvas>
              <div class="artFallback" id="artFallback" style="display: none">
                Put <b>sleep_kev.png</b> in the same folder.<br /><br />
                Expected: 7 frames, each 120×120,<br />
                laid out 3 across, then wraps down.
              </div>
            </div>

            <div class="statGrid">
              <div class="stat">
                <div class="label">Words loaded</div>
                <div class="value" id="statTotal">0</div>
              </div>
              <div class="stat">
                <div class="label">This level size</div>
                <div class="value" id="statLevelSize">0</div>
              </div>
              <div class="stat">
                <div class="label">Lives</div>
                <div class="value" id="statLives">6</div>
              </div>
              <div class="stat">
                <div class="label">Streak</div>
                <div class="value" id="statStreak">0</div>
              </div>
            </div>

            <!-- hidden file info block -->
            <div style="display: none">
              Sprite: sleep_kev.png / CSV: jlpt_vocab.csv / Music:
              assets/music/bgm.mp3
            </div>
          </div>
        </section>

        <audio id="bgm" src="assets/music/bgm.mp3" loop preload="auto"></audio>
      </aside>
    </div>

    <script>
      // ========= DOM =========
      const modeSelect = document.getElementById("modeSelect");
      const levelSelect = document.getElementById("levelSelect");
      const btnPrevLevel = document.getElementById("btnPrevLevel");
      const btnNextLevel = document.getElementById("btnNextLevel");
      const btnLoadLevel = document.getElementById("btnLoadLevel");
      const btnStart = document.getElementById("btnStart");
      const btnResetRun = document.getElementById("btnResetRun");

      const kanjiText = document.getElementById("kanjiText");
      const meaningText = document.getElementById("meaningText");
      const furiganaLine = document.getElementById("furiganaLine");
      const blanksEl = document.getElementById("blanks");

      const guessBar = document.getElementById("guessBar");
      const fullGuess = document.getElementById("fullGuess");
      const kanaGuess = document.getElementById("kanaGuess");
      const btnSubmit = document.getElementById("btnSubmit");
      const btnHint = document.getElementById("btnHint");
      const btnSkip = document.getElementById("btnSkip");

      const kbdHint = document.getElementById("kbdHint");
      const keyboardEl = document.getElementById("keyboard");

      const mcqArea = document.getElementById("mcqArea");
      const mcqGrid = document.getElementById("mcqGrid");
      const mcqHint = document.getElementById("mcqHint");

      const toastDot = document.querySelector("#toast .dot");
      const toastText = document.getElementById("toastText");

      const statTotal = document.getElementById("statTotal");
      const statLevelSize = document.getElementById("statLevelSize");
      const statLives = document.getElementById("statLives");
      const statStreak = document.getElementById("statStreak");

      const bgm = document.getElementById("bgm");
      const btnMusic = document.getElementById("btnMusic");

      const spriteCanvas = document.getElementById("spriteCanvas");
      const ctx = spriteCanvas.getContext("2d");
      const artFallback = document.getElementById("artFallback");

      // Hidden debug
      const statusPill = document.getElementById("statusPill");

      // ========= CONFIG =========
      const WORDS_PER_LEVEL = 100;

      // Sprite sheet: 7 frames, each 120x120, arranged 3 across then wrap down.
      const SPRITE_FILE = "sleep_kev.png";
      const SPRITE_FRAMES = 7;
      const SPRITE_FRAME_W = 120;
      const SPRITE_FRAME_H = 120;
      const SPRITE_COLS = 3;

      const MAX_WRONG = 6; // wrong: 0..6 -> frame 0..6

      // Reorder: N5 -> N4 -> N3 -> N2 -> N1 (each section already easiest->hardest)
      const JLPT_ORDER = ["N5", "N4", "N3", "N2", "N1"];

      // QWERTY (Easy mode letter guessing)
      const QWERTY_ROWS = ["qwertyuiop", "asdfghjkl", "zxcvbnm"];

      // Hiragana keyboard (Normal mode)
      const HIRA_ROWS = [
        "あいうえお",
        "かきくけこ",
        "さしすせそ",
        "たちつてと",
        "なにぬねの",
        "はひふへほ",
        "まみむめも",
        "やゆよ",
        "らりるれろ",
        "わをん",
        "がぎぐげご",
        "ざじずぜぞ",
        "だぢづでど",
        "ばびぶべぼ",
        "ぱぴぷぺぽ",
        "ゃゅょっー",
        "ぁぃぅぇぉ",
      ];

      // ========= STATE =========
      let orderedWords = []; // reordered N5->N1 (capped to 8100)
      let totalLevels = 1;

      let levelSlice = []; // 100 words for current level
      let levelWords = []; // playable subset (needs furigana)
      let remaining = [];

      let current = null;
      let targetRomaji = "";
      let targetKanaNorm = "";

      let displayLetters = [];
      let revealed = new Set();
      let guessedLetters = new Set();
      let wrong = 0;

      let solved = 0;
      let streak = 0;

      let spriteImg = new Image();
      let spriteReady = false;

      // ========= Helpers =========
      function getMode() {
        return modeSelect.value;
      }

      function setToast(type, msg) {
        toastText.textContent = msg;
        toastDot.classList.remove("ok", "bad");
        toastDot.classList.add(type === "ok" ? "ok" : "bad");
      }

      function updateStats() {
        statTotal.textContent = String(orderedWords.length);
        statLevelSize.textContent = String(levelSlice.length);
        statLives.textContent = String(Math.max(0, MAX_WRONG - wrong));
        statStreak.textContent = String(streak);
      }

      function beep(kind = "ok") {
        try {
          const ac = new (window.AudioContext || window.webkitAudioContext)();
          const o = ac.createOscillator();
          const g = ac.createGain();
          o.type = "sine";
          o.frequency.value = kind === "ok" ? 660 : 220;
          g.gain.value = 0.07;
          o.connect(g);
          g.connect(ac.destination);
          o.start();
          o.stop(ac.currentTime + 0.08);
          setTimeout(() => ac.close(), 150);
        } catch (e) {}
      }

      function normalizeRomaji(s) {
        return (s || "")
          .toLowerCase()
          .trim()
          .replace(/[’']/g, "")
          .replace(/[-\s_]/g, "")
          .replace(/ā/g, "aa")
          .replace(/ī/g, "ii")
          .replace(/ū/g, "uu")
          .replace(/ē/g, "ee")
          .replace(/ō/g, "ou");
      }

      function normalizeKana(s) {
        return (s || "")
          .trim()
          .replace(/\s+/g, "")
          .replace(
            /[()（）［］\[\]{}「」『』【】<>＜＞・,，.。！!？?／/\\]/g,
            ""
          );
      }

      function shuffle(arr) {
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      }

      // ========= CSV parsing (quoted commas) =========
      function parseCSV(text) {
        const rows = [];
        let row = [];
        let cell = "";
        let inQuotes = false;

        for (let i = 0; i < text.length; i++) {
          const ch = text[i];
          const next = text[i + 1];

          if (ch === '"') {
            if (inQuotes && next === '"') {
              cell += '"';
              i++;
            } else inQuotes = !inQuotes;
          } else if (ch === "," && !inQuotes) {
            row.push(cell);
            cell = "";
          } else if ((ch === "\n" || ch === "\r") && !inQuotes) {
            if (ch === "\r" && next === "\n") i++;
            row.push(cell);
            if (row.join("").trim() !== "") rows.push(row);
            row = [];
            cell = "";
          } else {
            cell += ch;
          }
        }
        row.push(cell);
        if (row.join("").trim() !== "") rows.push(row);
        return rows;
      }

      // ========= Kana -> Romaji (simple) =========
      function kataToHira(s) {
        return (s || "").replace(/[\u30a1-\u30f6]/g, (ch) =>
          String.fromCharCode(ch.charCodeAt(0) - 0x60)
        );
      }

      function kanaToRomaji(kanaRaw) {
        let s = kataToHira((kanaRaw || "").trim()).replace(/\s+/g, "");

        const digraph = {
          きゃ: "kya",
          きゅ: "kyu",
          きょ: "kyo",
          ぎゃ: "gya",
          ぎゅ: "gyu",
          ぎょ: "gyo",
          しゃ: "sha",
          しゅ: "shu",
          しょ: "sho",
          じゃ: "ja",
          じゅ: "ju",
          じょ: "jo",
          ちゃ: "cha",
          ちゅ: "chu",
          ちょ: "cho",
          にゃ: "nya",
          にゅ: "nyu",
          にょ: "nyo",
          ひゃ: "hya",
          ひゅ: "hyu",
          ひょ: "hyo",
          びゃ: "bya",
          びゅ: "byu",
          びょ: "byo",
          ぴゃ: "pya",
          ぴゅ: "pyu",
          ぴょ: "pyo",
          みゃ: "mya",
          みゅ: "myu",
          みょ: "myo",
          りゃ: "rya",
          りゅ: "ryu",
          りょ: "ryo",
        };
        const mono = {
          あ: "a",
          い: "i",
          う: "u",
          え: "e",
          お: "o",
          か: "ka",
          き: "ki",
          く: "ku",
          け: "ke",
          こ: "ko",
          さ: "sa",
          し: "shi",
          す: "su",
          せ: "se",
          そ: "so",
          た: "ta",
          ち: "chi",
          つ: "tsu",
          て: "te",
          と: "to",
          な: "na",
          に: "ni",
          ぬ: "nu",
          ね: "ne",
          の: "no",
          は: "ha",
          ひ: "hi",
          ふ: "fu",
          へ: "he",
          ほ: "ho",
          ま: "ma",
          み: "mi",
          む: "mu",
          め: "me",
          も: "mo",
          や: "ya",
          ゆ: "yu",
          よ: "yo",
          ら: "ra",
          り: "ri",
          る: "ru",
          れ: "re",
          ろ: "ro",
          わ: "wa",
          を: "o",
          ん: "n",
          が: "ga",
          ぎ: "gi",
          ぐ: "gu",
          げ: "ge",
          ご: "go",
          ざ: "za",
          じ: "ji",
          ず: "zu",
          ぜ: "ze",
          ぞ: "zo",
          だ: "da",
          ぢ: "ji",
          づ: "zu",
          で: "de",
          ど: "do",
          ば: "ba",
          び: "bi",
          ぶ: "bu",
          べ: "be",
          ぼ: "bo",
          ぱ: "pa",
          ぴ: "pi",
          ぷ: "pu",
          ぺ: "pe",
          ぽ: "po",
          ぁ: "a",
          ぃ: "i",
          ぅ: "u",
          ぇ: "e",
          ぉ: "o",
          ゃ: "ya",
          ゅ: "yu",
          ょ: "yo",
          ゔ: "vu",
        };

        let out = "";
        let gem = false;

        function lastVowel(str) {
          for (let i = str.length - 1; i >= 0; i--) {
            if ("aeiou".includes(str[i])) return str[i];
          }
          return "";
        }

        for (let i = 0; i < s.length; i++) {
          const ch = s[i];
          const next = s[i + 1] || "";
          const pair = ch + next;

          if (ch === "っ") {
            gem = true;
            continue;
          }
          if (ch === "ー") {
            const v = lastVowel(out);
            if (v) out += v;
            continue;
          }

          let roma = "";
          if (digraph[pair]) {
            roma = digraph[pair];
            i++;
          } else if (mono[ch]) {
            roma = mono[ch];
          } else {
            continue;
          }

          if (gem) {
            const c0 = roma[0];
            if (c0 && !"aeiou".includes(c0)) out += c0;
            gem = false;
          }
          out += roma;
        }
        return out;
      }

      // ========= Sprite (3-wide grid) =========
      function initSprite() {
        spriteImg = new Image();
        spriteImg.src = SPRITE_FILE;

        spriteImg.onload = () => {
          spriteReady = true;
          artFallback.style.display = "none";
          drawSpriteFrame(0);
        };

        spriteImg.onerror = () => {
          spriteReady = false;
          artFallback.style.display = "flex";
          ctx.clearRect(0, 0, spriteCanvas.width, spriteCanvas.height);
        };
      }

      function drawSpriteFrame(frameIndex) {
        if (!spriteReady) return;

        const fi = Math.max(0, Math.min(SPRITE_FRAMES - 1, frameIndex));
        const col = fi % SPRITE_COLS;
        const row = Math.floor(fi / SPRITE_COLS);

        const sx = col * SPRITE_FRAME_W;
        const sy = row * SPRITE_FRAME_H;

        ctx.clearRect(0, 0, spriteCanvas.width, spriteCanvas.height);
        ctx.imageSmoothingEnabled = false;

        ctx.drawImage(
          spriteImg,
          sx,
          sy,
          SPRITE_FRAME_W,
          SPRITE_FRAME_H,
          0,
          0,
          spriteCanvas.width,
          spriteCanvas.height
        );
      }

      function setFrameByWrong() {
        drawSpriteFrame(Math.min(SPRITE_FRAMES - 1, wrong));
      }

      // ========= Keyboard builder =========
      function clearKeyboard() {
        keyboardEl.innerHTML = "";
      }

      function makeRow(chars, isKana) {
        const row = document.createElement("div");
        row.className = "kbdRow";
        chars.forEach((ch) => {
          const b = document.createElement("button");
          b.className = "key" + (isKana ? " kana" : "");
          b.textContent = ch;
          if (isKana) {
            b.addEventListener("click", () => onKanaKey(ch));
          } else {
            b.addEventListener("click", () => onLetterGuess(ch));
          }
          row.appendChild(b);
        });
        return row;
      }

      function addControlRow(isKana) {
        const row = document.createElement("div");
        row.className = "kbdRow";

        const back = document.createElement("button");
        back.className = "key wide" + (isKana ? " kana" : "");
        back.textContent = "⌫";
        back.title = "Backspace";
        back.addEventListener("click", () => {
          if (isKana) {
            kanaGuess.value = kanaGuess.value.slice(0, -1);
            kanaGuess.focus();
          } else {
            fullGuess.value = fullGuess.value.slice(0, -1);
            fullGuess.focus();
          }
        });

        const clr = document.createElement("button");
        clr.className = "key wide" + (isKana ? " kana" : "");
        clr.textContent = "clr";
        clr.title = "Clear";
        clr.addEventListener("click", () => {
          if (isKana) {
            kanaGuess.value = "";
            kanaGuess.focus();
          } else {
            fullGuess.value = "";
            fullGuess.focus();
          }
        });

        row.appendChild(back);
        row.appendChild(clr);
        return row;
      }

      function buildKeyboardForMode() {
        clearKeyboard();

        const mode = getMode();
        if (mode === "easy") {
          // QWERTY letter selection
          QWERTY_ROWS.forEach((r) =>
            keyboardEl.appendChild(makeRow(r.split(""), false))
          );
          keyboardEl.appendChild(addControlRow(false));
          kbdHint.style.display = "block";
          kbdHint.textContent = "Click letters (QWERTY) for hangman guesses.";
          keyboardEl.style.display = "flex";
        } else if (mode === "normal") {
          // Hiragana selection
          HIRA_ROWS.forEach((r) =>
            keyboardEl.appendChild(makeRow(r.split(""), true))
          );
          keyboardEl.appendChild(addControlRow(true));
          kbdHint.style.display = "block";
          kbdHint.textContent =
            "Click hiragana to build the reading (or type romaji).";
          keyboardEl.style.display = "flex";
        } else {
          // Hard mode: no keyboard
          kbdHint.style.display = "none";
          keyboardEl.style.display = "none";
        }
      }

      function resetLetterKeyStates() {
        keyboardEl.querySelectorAll(".key").forEach((k) => {
          k.classList.remove("used", "good", "bad");
          k.disabled = false;
        });
      }

      function markLetterKey(ch, status) {
        const key = [...keyboardEl.querySelectorAll(".key")].find(
          (k) => k.textContent === ch
        );
        if (!key) return;
        key.classList.add("used");
        if (status === "good") key.classList.add("good");
        if (status === "bad") key.classList.add("bad");
        key.disabled = true;
      }

      // ========= Level UI =========
      function initLevelSelect(levelCount) {
        levelSelect.innerHTML = "";
        for (let i = 1; i <= levelCount; i++) {
          const opt = document.createElement("option");
          opt.value = String(i);
          opt.textContent = `Level ${i}`;
          levelSelect.appendChild(opt);
        }
        levelSelect.value = "1";
      }

      // ========= CSV reorder: N5->N1 =========
      function getColumnIndexes(headerRow) {
        const header = (headerRow || []).map((h) =>
          (h || "").trim().toLowerCase()
        );
        const idxOriginal =
          header.indexOf("original") >= 0 ? header.indexOf("original") : 0;
        const idxFurigana =
          header.indexOf("furigana") >= 0 ? header.indexOf("furigana") : 1;
        const idxEnglish =
          header.indexOf("english") >= 0 ? header.indexOf("english") : 2;

        let idxJLPT = header.indexOf("jlpt level");
        if (idxJLPT < 0) idxJLPT = header.indexOf("jlpt");
        if (idxJLPT < 0) idxJLPT = header.indexOf("level");
        return { idxOriginal, idxFurigana, idxEnglish, idxJLPT };
      }

      function reorderRowsToWords(rows) {
        const { idxOriginal, idxFurigana, idxEnglish, idxJLPT } =
          getColumnIndexes(rows[0] || []);
        const groups = { N5: [], N4: [], N3: [], N2: [], N1: [], OTHER: [] };

        for (let r = 1; r < rows.length; r++) {
          const row = rows[r] || [];
          const kanji = (row[idxOriginal] ?? "").trim();
          const furigana = (row[idxFurigana] ?? "").trim();
          const meaning = (row[idxEnglish] ?? "").trim();

          const jlptRaw = (idxJLPT >= 0 ? row[idxJLPT] ?? "" : "")
            .toString()
            .trim()
            .toUpperCase();
          const jlpt = jlptRaw.match(/^N[1-5]$/) ? jlptRaw : "OTHER";

          const furiganaH = kataToHira(furigana);
          const romaji = furigana
            ? normalizeRomaji(kanaToRomaji(furiganaH))
            : "";

          const w = {
            kanji: kanji || "—",
            meaning: meaning || "—",
            furigana: furigana || "",
            furiganaH: furiganaH || "",
            romaji,
            jlpt,
          };

          if (groups[jlpt]) groups[jlpt].push(w);
          else groups.OTHER.push(w);
        }

        const ordered = [
          ...groups.N5,
          ...groups.N4,
          ...groups.N3,
          ...groups.N2,
          ...groups.N1,
          ...groups.OTHER,
        ];
        const counts = {
          N5: groups.N5.length,
          N4: groups.N4.length,
          N3: groups.N3.length,
          N2: groups.N2.length,
          N1: groups.N1.length,
          OTHER: groups.OTHER.length,
        };
        return { ordered, counts };
      }

      // ========= Load CSV =========
      async function loadCSVAuto() {
        try {
          const res = await fetch("jlpt_vocab.csv", { cache: "no-store" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);

          const text = await res.text();
          const rows = parseCSV(text);
          if (rows.length < 2) throw new Error("CSV has no data rows.");

          const { ordered, counts } = reorderRowsToWords(rows);

          // exactly 81 levels * 100 words = 8100
          const MAX_WORDS = 81 * 100;
          orderedWords = ordered.slice(0, MAX_WORDS);

          statusPill.textContent = `Loaded ${orderedWords.length} — N5:${counts.N5} N4:${counts.N4} N3:${counts.N3} N2:${counts.N2} N1:${counts.N1}`;

          totalLevels = Math.max(
            1,
            Math.ceil(orderedWords.length / WORDS_PER_LEVEL)
          );
          initLevelSelect(totalLevels);

          btnLoadLevel.disabled = false;

          // Auto-load level 1
          loadSelectedLevel();

          setToast("ok", "Ready.");
          updateStats();
        } catch (err) {
          console.error(err);
          setToast("bad", "Couldn’t load jlpt_vocab.csv (use a local server).");
        }
      }

      function loadSelectedLevel() {
        const lvl = Number(levelSelect.value);
        const startIdx = (lvl - 1) * WORDS_PER_LEVEL;
        const endIdx = Math.min(
          orderedWords.length,
          startIdx + WORDS_PER_LEVEL
        );

        levelSlice = orderedWords.slice(startIdx, endIdx);

        // playable requires a reading we can test against (furigana)
        levelWords = levelSlice.filter(
          (w) => w.furiganaH && normalizeKana(w.furiganaH).length > 0
        );

        resetRunState();
        btnResetRun.disabled = false;
        btnStart.disabled = levelWords.length === 0;

        updateStats();
        setToast(
          levelWords.length ? "ok" : "bad",
          levelWords.length
            ? "Level loaded."
            : "No playable words in this level."
        );
      }

      // ========= Mode UI =========
      function applyModeUI() {
        const mode = getMode();

        // Default: show Kanji + English
        kanjiText.style.display = "block";
        meaningText.classList.remove("hard");
        furiganaLine.style.display = "none";
        blanksEl.style.display = "flex";

        // Inputs/buttons default
        fullGuess.style.display = "inline-block";
        kanaGuess.style.display = "none";
        btnSubmit.style.display = "inline-block";
        btnHint.style.display = "inline-block";
        guessBar.style.display = "flex";

        // Areas
        mcqArea.style.display = "none";
        keyboardEl.style.display = "flex";
        kbdHint.style.display = "block";

        if (mode === "easy") {
          // Show furigana + hangman letters (QWERTY)
          furiganaLine.style.display = "block";
          blanksEl.style.display = "flex";
          kanaGuess.style.display = "none";
          btnHint.style.display = "inline-block";
        }

        if (mode === "normal") {
          // Hide furigana, no hangman blanks; use romaji input OR kana keyboard builder
          furiganaLine.style.display = "none";
          blanksEl.style.display = "none";
          kanaGuess.style.display = "inline-block";
          btnHint.style.display = "none";
        }

        if (mode === "hard") {
          // Only English + 21 MCQ options
          kanjiText.style.display = "none";
          furiganaLine.style.display = "none";
          blanksEl.style.display = "none";
          meaningText.classList.add("hard");

          // Hide input/submit/hint; keep skip
          fullGuess.style.display = "none";
          kanaGuess.style.display = "none";
          btnSubmit.style.display = "none";
          btnHint.style.display = "none";

          // Hide keyboard; show MCQ
          keyboardEl.style.display = "none";
          kbdHint.style.display = "none";
          mcqArea.style.display = "block";
        }

        buildKeyboardForMode();
      }

      // ========= Game =========
      function renderBlanks() {
        blanksEl.innerHTML = "";
        displayLetters.forEach((ch, i) => {
          const slot = document.createElement("div");
          slot.className = "slot" + (revealed.has(i) ? " revealed" : "");
          slot.textContent = revealed.has(i) ? ch : " ";
          blanksEl.appendChild(slot);
        });
      }

      function revealAllLetters() {
        revealed = new Set(displayLetters.map((_, i) => i));
        renderBlanks();
      }

      function isSolvedLetters() {
        return revealed.size >= displayLetters.length;
      }

      function resetRunState() {
        // Rebuild remaining pool for this run
        remaining = levelWords.map((_, i) => i);

        current = null;
        targetRomaji = "";
        targetKanaNorm = "";

        displayLetters = [];
        revealed = new Set();
        guessedLetters = new Set();
        wrong = 0;

        solved = 0;
        streak = 0;

        fullGuess.value = "";
        kanaGuess.value = "";
        blanksEl.innerHTML = "";
        mcqGrid.innerHTML = "";

        kanjiText.textContent = "—";
        meaningText.textContent = "—";
        furiganaLine.textContent = "Furigana: —";

        setFrameByWrong();
        applyModeUI();
        resetLetterKeyStates();
        updateStats();
      }

      function pickNextIndex() {
        if (remaining.length === 0) return -1;
        const r = Math.floor(Math.random() * remaining.length);
        return remaining.splice(r, 1)[0];
      }

      function startRun() {
        if (!levelWords.length) {
          setToast("bad", "No playable words in this level.");
          return;
        }

        // fresh run
        remaining = levelWords.map((_, i) => i);
        solved = 0;
        streak = 0;

        btnStart.disabled = true;
        nextWord();
        setToast("ok", "Run started.");
        updateStats();
      }

      function nextWord() {
        const idx = pickNextIndex();
        if (idx === -1) {
          setToast("ok", `Finished! Solved ${solved}/${levelWords.length}.`);
          btnStart.disabled = false;
          return;
        }

        current = levelWords[idx];

        // per-word reset
        wrong = 0;
        guessedLetters = new Set();
        revealed = new Set();
        fullGuess.value = "";
        kanaGuess.value = "";
        mcqGrid.innerHTML = "";

        kanjiText.textContent = current.kanji;
        meaningText.textContent = current.meaning;
        furiganaLine.textContent = `Furigana: ${current.furigana || "—"}`;

        // Targets
        targetKanaNorm = normalizeKana(current.furiganaH);
        targetRomaji =
          current.romaji || normalizeRomaji(kanaToRomaji(current.furiganaH));

        // Easy-mode blanks are for romaji letters
        displayLetters = (targetRomaji || "").split("");
        renderBlanks();

        setFrameByWrong();
        applyModeUI();
        resetLetterKeyStates();

        // Hard mode: build 21 choices (from same level)
        if (getMode() === "hard") {
          buildMCQChoices();
        }

        updateStats();

        // Focus best input
        if (getMode() === "normal") fullGuess.focus();
        if (getMode() === "easy") fullGuess.focus();
      }

      function loseLife(extraMsg) {
        wrong++;
        setFrameByWrong();
        beep("bad");
        const left = Math.max(0, MAX_WRONG - wrong);
        setToast(
          "bad",
          extraMsg
            ? `${extraMsg}  Lives left: ${left}`
            : `Wrong. Lives left: ${left}`
        );
        updateStats();

        if (wrong >= MAX_WRONG) {
          streak = 0;

          // Reveal answer in toast, then move on
          const answer = current
            ? current.furigana || targetRomaji || "—"
            : "—";
          setToast("bad", `Out of lives. Answer: ${answer}`);

          // Show solved letters if easy mode
          if (getMode() === "easy") {
            revealAllLetters();
          }

          updateStats();
          setTimeout(nextWord, 900);
        }
      }

      function winWord() {
        beep("ok");
        solved++;
        streak++;
        updateStats();

        if (getMode() === "easy") {
          revealAllLetters();
        }

        setToast("ok", "Correct!");
        setTimeout(nextWord, 650);
      }

      // ========= EASY: letter guessing =========
      function onLetterGuess(ch) {
        if (getMode() !== "easy") return;
        if (!current) return;

        ch = normalizeRomaji(ch);
        if (!ch || ch.length !== 1) return;
        if (guessedLetters.has(ch)) return;

        guessedLetters.add(ch);

        if (targetRomaji.includes(ch)) {
          displayLetters.forEach((c, i) => {
            if (c === ch) revealed.add(i);
          });
          markLetterKey(ch, "good");
          beep("ok");
          renderBlanks();
          if (isSolvedLetters()) winWord();
        } else {
          markLetterKey(ch, "bad");
          loseLife();
        }
      }

      // ========= NORMAL: kana building =========
      function onKanaKey(kana) {
        if (getMode() !== "normal") return;
        if (!current) return;
        kanaGuess.value += kana;
      }

      // ========= Submit (Easy/Normal) =========
      function submitGuess() {
        if (!current) return;

        const mode = getMode();
        if (mode === "hard") return;

        const romajiGuess = normalizeRomaji(fullGuess.value);

        if (mode === "easy") {
          if (!romajiGuess) return;
          if (romajiGuess === targetRomaji) {
            winWord();
          } else {
            loseLife();
            fullGuess.select();
          }
          return;
        }

        // normal: accept romaji OR kana
        const kanaGuessNorm = normalizeKana(kataToHira(kanaGuess.value));
        const kanaOK = kanaGuessNorm && kanaGuessNorm === targetKanaNorm;
        const romajiOK = romajiGuess && romajiGuess === targetRomaji;

        if (kanaOK || romajiOK) {
          winWord();
        } else {
          loseLife();
          fullGuess.select();
        }
      }

      // ========= Hard mode MCQ =========
      function buildMCQChoices() {
        if (getMode() !== "hard") return;
        if (!current) return;

        // Use readings from same level; 21 options if possible
        const needed = Math.min(21, levelWords.length);

        // Unique by normalized kana to avoid duplicates
        const correctKey = normalizeKana(current.furiganaH);
        const pool = levelWords
          .filter((w) => w !== current)
          .filter((w) => normalizeKana(w.furiganaH) !== correctKey);

        shuffle(pool);

        const picks = [];
        const used = new Set();

        // add correct
        picks.push(current);
        used.add(correctKey);

        for (const w of pool) {
          if (picks.length >= needed) break;
          const k = normalizeKana(w.furiganaH);
          if (used.has(k)) continue;
          used.add(k);
          picks.push(w);
        }

        shuffle(picks);

        mcqHint.textContent = `Pick the correct reading (${picks.length} options).`;
        mcqGrid.innerHTML = "";

        picks.forEach((w) => {
          const b = document.createElement("button");
          b.className = "mcqBtn";
          b.textContent = w.furigana || w.furiganaH || "—";
          b.addEventListener("click", () => {
            onMCQPick(w, b);
          });
          mcqGrid.appendChild(b);
        });
      }

      function onMCQPick(word, btn) {
        if (getMode() !== "hard") return;
        if (!current) return;

        const correct =
          normalizeKana(word.furiganaH) === normalizeKana(current.furiganaH);
        if (correct) {
          btn.classList.add("good");
          // disable all
          [...mcqGrid.querySelectorAll("button")].forEach(
            (b) => (b.disabled = true)
          );
          winWord();
        } else {
          btn.classList.add("bad");
          btn.disabled = true;
          loseLife("Nope.");
        }
      }

      // ========= Hint/Skip =========
      function hint() {
        if (getMode() !== "easy") return;
        if (!current) return;

        const hidden = [];
        for (let i = 0; i < displayLetters.length; i++) {
          if (!revealed.has(i)) hidden.push(i);
        }
        if (hidden.length === 0) return;

        const pick = hidden[Math.floor(Math.random() * hidden.length)];
        revealed.add(pick);
        renderBlanks();

        setToast("ok", "Hint used.");
        if (isSolvedLetters()) winWord();
      }

      function skipWord() {
        if (!current) return;
        streak = 0;
        setToast(
          "bad",
          `Skipped. Answer: ${current.furigana || targetRomaji || "—"}`
        );
        updateStats();
        setTimeout(nextWord, 350);
      }

      // ========= Music =========
      async function toggleMusic() {
        try {
          if (bgm.paused) {
            await bgm.play();
            btnMusic.textContent = "Pause Music";
          } else {
            bgm.pause();
            btnMusic.textContent = "Play Music";
          }
        } catch (e) {
          setToast("bad", "Music couldn't start (check assets/music/bgm.mp3).");
        }
      }

      // ========= Events =========
      btnLoadLevel.addEventListener("click", loadSelectedLevel);
      btnStart.addEventListener("click", startRun);

      btnResetRun.addEventListener("click", () => {
        resetRunState();
        setToast("ok", "Reset.");
        btnStart.disabled = levelWords.length === 0;
      });

      btnPrevLevel.addEventListener("click", () => {
        const v = Math.max(1, Number(levelSelect.value) - 1);
        levelSelect.value = String(v);
      });

      btnNextLevel.addEventListener("click", () => {
        const v = Math.min(totalLevels, Number(levelSelect.value) + 1);
        levelSelect.value = String(v);
      });

      // Mode change resets run so UI + logic stays consistent
      modeSelect.addEventListener("change", () => {
        resetRunState();
        btnStart.disabled = levelWords.length === 0;
        setToast("ok", `Mode: ${getMode()}`);
      });

      btnSubmit.addEventListener("click", submitGuess);
      fullGuess.addEventListener("keydown", (e) => {
        if (e.key === "Enter") {
          e.preventDefault();
          submitGuess();
        }
      });

      btnHint.addEventListener("click", hint);
      btnSkip.addEventListener("click", skipWord);

      btnMusic.addEventListener("click", toggleMusic);

      // ========= Init =========
      initSprite();
      buildKeyboardForMode();
      applyModeUI();
      setToast("ok", "Loading jlpt_vocab.csv…");
      updateStats();
      loadCSVAuto();
    </script>
  </body>
</html>
